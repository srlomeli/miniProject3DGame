Design Document: 3D Endless Runner
=============================================

Royal Run

Unity Play Link: https://play.unity.com/en/games/56848322-5102-4b96-a72a-713842cd35c9/runbuild

1. Game Concept and Genre
--------------------------

- **Genre:** 3D Procedural Endless Runner
    
- **Concept:** This project extends a base endless runner. The player controls a "King" character who automatically runs forward on a path that is procedurally generated by "chunks". The primary objective is survival. The player must dodge a variety of randomly spawned obstacles while collecting pickups like coins and apples to increase their score and remaining time. The game ends when the player's time runs out.
    

1. List of Implemented Base Requirements
-----------------------------------------

1.  **Player Control & Input:**
    
    - Responsive player movement (left/right) is handled via the PlayerController script.
        
    - Input is managed using Unity's modern Input System, defined in the PlayerControls.inputactions asset.
        
2.  **Game Objects & Spawning:**
    
    - The game features well over 3 types of interactive objects, including:
        
        - **Obstacles:** Barrel.prefab, Bench.prefab, Cart.prefab, Rock.prefab.
            
        - **Collectibles:** Coin Pickup.prefab, Apple Pickup.prefab.
            
    - A dynamic spawning system (ObstacleSpawner.cs) randomly places these prefabs within the procedurally generated level chunks.
        
3.  **Game State Management:**
    
    - A central GameManager.cs controls the game flow using boolean variables isGameActive and gameOver.
        
    - **Loss Conditions:** The game ends when the player's time runs out (timeLeft <= 0f).
        
    - **Score Tracking:** A ScoreManager tracks the player's score.
        
    - **Restart:** A restart mechanism is implemented in both the GameManager (showing the restart button) and the PauseManager (reloading the scene).
        
4.  **Visual & Audio Feedback:**
    
    - **Particle Effects (2+):** The game uses particle effects for atmosphere (Fog Particle.mat) and gameplay feedback (Speed Up Particle.mat).
        
    - **Sound Effects (3+):** The game includes background music, collision sounds, and pickup sounds for collectibles.
        
    - **Visual Feedback:** The UI updates dynamically. The ScoreManager updates scoreText and highScoreText, and the GameManager updates timeText.
        
5.  **User Interface:**
    
    - **Title Screen:** GameManager displays a titleScreenPanel when the game starts (isGameActive is false).
        
    - **Game Over Screen:** A gameOverText object is activated when the player loses.
        
    - **Gameplay Display:** An inGameUIPanel displays the player's "Current Score", "High Score", and "Time Left" during gameplay, using TextMeshPro text elements.
        
    - **Restart Mechanism:** A restartButton is shown on the Game Over screen, and a "Restart" button is also available in the pause menu.
        
6.  **Code Quality:**
    
    - Scripts are organized into logical sub-folders (Managers, Player, Pickups, Proc Gen).
        
    - [Header] attributes are used in GameManager.cs for inspector organization.
        
    - Variables (isGameActive, highScore, timeLeft) and methods (PlayerGameOver, CheckHighScore, StartGame) have clear, descriptive names.
        

3. List of 3+ Extension Features
---------------------------------

1.  **Persistent High Score System (using PlayerPrefs):**
    
    - The ScoreManager successfully saves the player's high score to disk. It uses PlayerPrefs.GetInt("HighScore", 0) on Start() to load the value and PlayerPrefs.SetInt("HighScore", highScore) to save it in the CheckHighScore() method, which is called upon game over.
        
2.  **Pause Menu with Resume Functionality:**
    
    - A complete pause system is implemented in PauseManager.cs. Pressing the Escape key toggles the pause state.
        
    - **Pause:** Time.timeScale is set to 0f, the pauseMenuPanel is activated, and the PlayerController is disabled to prevent input.
        
    - **Resume:** Time.timeScale is restored to 1f, the panel is hidden, and the PlayerController is re-enabled.
        
3.  **Difficulty Scaling System:**
    
    - The game's difficulty scales in multiple ways as the player progresses.
        
    - **Limited Resources:** The game is time-based. The player starts with a low amount of time (startTime = 30f) and must constantly collect Apple pickups to increase the speed to reach the next time boost checkpoint.
        
    - **Obstacles:** The player's movement speed decreases after being hit or running into obstancles.
        
    - **Increased Spawning:** The rate at which obstacles are spawned also increases over time.
        

4. Challenges Encountered and Solutions
----------------------------------------

- **Challenge 1: Infinite Level Generation & Performance**
    
    - **Problem:** Creating a truly "endless" level would be impossible. Spawning thousands of objects would eventually cause extreme lag and crash the game.
        
    - **Solution:** A modular "chunk" system was implemented. The LevelGenerator only spawns a few Chunk prefabs ahead of the player. To manage memory, a script (ObstacleDestroy.cs) is attached to a trigger behind the player that destroys any chunks and obstacles that have been passed, keeping the total object count manageable.
        
- **Challenge 2: Complex Game State Management**
    
    - **Problem:** Managing the game's state (Title Screen, Playing, Paused, Game Over) and ensuring UI panels, player input, and time scale all behave correctly for each state.
        
    - **Solution:** This was solved by creating dedicated, singleton-like manager scripts. The GameManager acts as the main controller, enabling/disabling other scripts (like PlayerController and PauseManager) based on game state. The PauseManager is given the specific job of handling Time.timeScale and the pause UI, which separates concerns and keeps the code clean.
        
- **Challenge 3: Persistent High Score**
    
    - **Problem:** ScoreManager could track a high score, but it would reset every time the game was closed.
        
    - **Solution:** PlayerPrefs was used to solve this. The ScoreManager now calls PlayerPrefs.GetInt() in Start() to load the saved score from disk and PlayerPrefs.SetInt() in CheckHighScore() to save a new record, making the high score persistent between sessions.
        

5. Assets Used 
------------------------------

- **Custom C# Scripts:**
    
    - All scripts located in the Assets/Scripts/ directory, including GameManager.cs, ScoreManager.cs, PauseManager.cs, PlayerController.cs, LevelGenerator.cs, ObstacleSpawner.cs, PlayerCollisionHandler.cs, Pickup.cs, etc.
                
- **Unity Packages (from Package Manager):**
    
    - **TextMesh Pro:** Used for all UI text elements.
        
    - **Input System:** Used for handling player controls.
